using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using VehicleTracking.Domain.Entities;
using VehicleTracking.Domain.Enumerations;

namespace VehicleTracking.Persistence
{
	public class VehicleTrackingDbContext : DbContext
	{
		public VehicleTrackingDbContext(DbContextOptions<VehicleTrackingDbContext> options)
			: base(options)
		{ }

		public DbSet<AuditLog> AuditLogs { get; set; }
		public DbSet<TrackingRecord> TrackingRecords { get; set; }
		public DbSet<TrackingRecordSnapshot> TrackingRecordSnapshots { get; set; }
		public DbSet<User> Users { get; set; }
		public DbSet<Vehicle> Vehicles { get; set; }

		protected override void OnModelCreating(ModelBuilder modelBuilder)
		{
			modelBuilder.ApplyConfigurationsFromAssembly(typeof(VehicleTrackingDbContext).Assembly);
		}

		public override int SaveChanges()
		{
			var auditEntries = OnBeforeSaveChange();
			var result = base.SaveChanges();
			OnAfterSaveChange(auditEntries).Wait();
			return result;
		}

		public override int SaveChanges(bool acceptAllChangesOnSuccess = true)
		{
			var auditEntries = OnBeforeSaveChange();
			var result = base.SaveChanges(acceptAllChangesOnSuccess);
			OnAfterSaveChange(auditEntries).Wait();
			return result;
		}

		public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
		{
			var auditEntries = OnBeforeSaveChange();
			var result = base.SaveChangesAsync(cancellationToken);
			OnAfterSaveChange(auditEntries).Wait();
			return result;
		}

		public override Task<int> SaveChangesAsync(bool acceptAllChangesOnSuccess = true, CancellationToken cancellationToken = default)
		{
			var auditEntries = OnBeforeSaveChange();
			var result = base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
			OnAfterSaveChange(auditEntries).Wait();
			return result;
		}

		private List<AuditEntry> OnBeforeSaveChange()
		{
			ChangeTracker.DetectChanges();

			var auditEntries = new List<AuditEntry>();

			foreach (var entry in ChangeTracker.Entries())
			{
				if (entry.Entity is AuditLog || entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
				{
					continue;
				}

				var auditEntry = new AuditEntry(entry);
				auditEntry.TableName = entry.Metadata.Relational().TableName;
				auditEntries.Add(auditEntry);

				foreach (var property in entry.Properties)
				{
					if (property.IsTemporary)
					{
						// value will be generated by the database, get the value after saving
						auditEntry.TemporaryProperties.Add(property);
						continue;
					}

					string propertyName = property.Metadata.Name;
					if (property.Metadata.IsPrimaryKey())
					{
						auditEntry.KeyValues[propertyName] = property.CurrentValue;
						continue;
					}

					switch (entry.State)
					{
						case EntityState.Added:
							auditEntry.Action = AuditAction.Create;
							auditEntry.NewValues[propertyName] = property.CurrentValue;
							break;

						case EntityState.Deleted:
							auditEntry.Action = AuditAction.Delete;
							auditEntry.OldValues[propertyName] = property.OriginalValue;
							break;

						case EntityState.Modified:
							if (property.IsModified)
							{
								auditEntry.Action = AuditAction.Update;
								auditEntry.OldValues[propertyName] = property.OriginalValue;
								auditEntry.NewValues[propertyName] = property.CurrentValue;
							}
							break;
					}
				}
			}

			// Save audit entities that have all the modifications
			foreach (var auditEntry in auditEntries.Where(_ => !_.HasTemporaryProperties))
			{
				AuditLogs.Add(auditEntry.ToAuditLog());
			}

			// keep a list of entries where the value of some properties are unknown at this step
			return auditEntries.Where(_ => _.HasTemporaryProperties).ToList();
		}

		private Task OnAfterSaveChange(List<AuditEntry> auditEntries)
		{
			if (auditEntries == null || auditEntries.Count == 0)
			{
				return Task.CompletedTask;
			}

			foreach (var auditEntry in auditEntries)
			{
				// Get the final value of the temporary properties
				foreach (var prop in auditEntry.TemporaryProperties)
				{
					if (prop.Metadata.IsPrimaryKey())
					{
						auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
					}
					else
					{
						auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
					}
				}

				// Save the Audit entry
				AuditLogs.Add(auditEntry.ToAuditLog());
			}

			return SaveChangesAsync(true);
		}
	}

	internal class AuditEntry
	{
		public AuditEntry(EntityEntry entry)
		{
			Entry = entry;
		}

		public EntityEntry Entry { get; }
		public string TableName { get; set; }
		public AuditAction Action { get; set; }
		public Dictionary<string, object> KeyValues { get; } = new Dictionary<string, object>();
		public Dictionary<string, object> OldValues { get; } = new Dictionary<string, object>();
		public Dictionary<string, object> NewValues { get; } = new Dictionary<string, object>();
		public List<PropertyEntry> TemporaryProperties { get; } = new List<PropertyEntry>();

		public bool HasTemporaryProperties => TemporaryProperties.Any();

		public AuditLog ToAuditLog()
		{
			var audit = new AuditLog();
			audit.TableName = TableName;
			audit.CreatedDate = DateTime.UtcNow;
			audit.KeyValues = JsonConvert.SerializeObject(KeyValues);
			audit.OldValues = OldValues.Count == 0 ? null : JsonConvert.SerializeObject(OldValues);
			audit.NewValues = NewValues.Count == 0 ? null : JsonConvert.SerializeObject(NewValues);
			audit.Action = Action;
			return audit;
		}
	}
}
